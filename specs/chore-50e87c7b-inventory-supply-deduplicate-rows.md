# Chore: Fix Duplicate Rows in Inventory Supply Page

## Metadata
adw_id: `50e87c7b`
prompt: `Fix duplicate rows in Inventory Supply page. The generateInventorySupplyData function in src/lib/mock-inventory-data.ts is generating duplicate entries with the same storeId + productId combination. Tasks: 1) In the generateInventorySupplyData function, add deduplication logic to ensure each storeId + productId combination only appears once. 2) Use a Set or Map to track unique combinations and skip duplicates during generation. 3) Alternatively, add a filter at the end of the function to remove duplicates based on a composite key of storeId + productId. 4) Ensure the returned data array has unique rows only. 5) Validate with pnpm build and verify no duplicate storeId + productId combinations exist in the generated data.`

## Chore Description
The Inventory Supply page (`app/inventory-new/supply/page.tsx`) displays data from `mockInventoryItems` which is generated by combining three sources:
1. `mockInventoryItemsBase` - Base inventory items
2. `generateMultiStoreProducts()` - Products distributed across multiple stores
3. `generateAdditionalItems()` - Additional items for pagination testing

The `ensureWarehouseLocationsAndNewFields()` function processes all items and assigns a `storeId` based on the `storeName`. The problem is that the same `productId + storeId` combination can appear multiple times across these three data sources, resulting in duplicate rows displayed in the UI.

The fix should add deduplication logic to ensure each `storeId + productId` combination appears only once in the final `mockInventoryItems` array.

## Relevant Files
Use these files to complete the chore:

- **`src/lib/mock-inventory-data.ts`** - Main file containing the mock inventory data generation logic. The `ensureWarehouseLocationsAndNewFields()` function (line 997) and the `mockInventoryItems` export (line 3224) are the key areas to modify.

- **`src/types/inventory.ts`** - Contains the `InventoryItem` interface (line 205) which defines the `productId` and `storeId` fields used for deduplication.

- **`app/inventory-new/supply/page.tsx`** - The Inventory Supply page that consumes `mockInventoryItems` via `fetchInventoryData()`. Understanding this helps verify the fix works correctly.

- **`src/lib/inventory-service.ts`** - The service layer that provides `fetchInventoryData()` which returns `mockInventoryItems`. No changes needed here, but useful for understanding data flow.

### New Files
None required.

## Step by Step Tasks
IMPORTANT: Execute every step in order, top to bottom.

### 1. Analyze Current Data Structure
- Confirm the data flow: `mockInventoryItems` is generated at line 3224 by calling `ensureWarehouseLocationsAndNewFields()` on the combined array of base items, multi-store products, and additional items
- The `storeId` is assigned inside `ensureWarehouseLocationsAndNewFields()` based on `storeName` lookup (lines 1022-1035)
- Duplicates can occur when items from different sources have the same `productId` and get assigned to the same store

### 2. Add Deduplication Logic to ensureWarehouseLocationsAndNewFields
- Modify the `ensureWarehouseLocationsAndNewFields()` function (starting at line 997) to track unique `storeId + productId` combinations
- Add a `Set` to track seen combinations: `const seenCombinations = new Set<string>()`
- After processing each item and before adding to the result, check if the combination exists:
  ```typescript
  const combinationKey = `${storeId}:${item.productId}`
  if (seenCombinations.has(combinationKey)) {
    return null // Skip duplicate
  }
  seenCombinations.add(combinationKey)
  ```
- Filter out null values from the final result

### 3. Implement the Deduplication Filter
- Change the function signature to filter out duplicates:
  ```typescript
  function ensureWarehouseLocationsAndNewFields(items: InventoryItem[]): InventoryItem[] {
    const seenCombinations = new Set<string>()

    return items.map(item => {
      // ... existing processing logic ...

      const combinationKey = `${storeId}:${item.productId}`
      if (seenCombinations.has(combinationKey)) {
        return null // Mark for removal
      }
      seenCombinations.add(combinationKey)

      return {
        ...item,
        // ... existing field assignments ...
      }
    }).filter((item): item is InventoryItem => item !== null)
  }
  ```

### 4. Alternative: Post-Processing Deduplication
- If modifying `ensureWarehouseLocationsAndNewFields` is complex, add a separate deduplication function:
  ```typescript
  function deduplicateInventoryItems(items: InventoryItem[]): InventoryItem[] {
    const seenCombinations = new Set<string>()
    return items.filter(item => {
      const key = `${item.storeId}:${item.productId}`
      if (seenCombinations.has(key)) {
        return false
      }
      seenCombinations.add(key)
      return true
    })
  }
  ```
- Apply it to the `mockInventoryItems` export:
  ```typescript
  export const mockInventoryItems = deduplicateInventoryItems(
    ensureWarehouseLocationsAndNewFields([
      ...mockInventoryItemsBase,
      ...generateMultiStoreProducts(),
      ...generateAdditionalItems()
    ])
  )
  ```

### 5. Validate the Implementation
- Run `pnpm build` to ensure TypeScript compiles without errors
- Verify that `mockInventoryItems` contains no duplicate `storeId + productId` combinations
- Test the Inventory Supply page to ensure data displays correctly without duplicate rows

## Validation Commands
Execute these commands to validate the chore is complete:

- `pnpm build` - Ensure TypeScript compiles without errors and the production build succeeds
- After build, manually verify in browser at `http://localhost:3000/inventory-new/supply` that searching returns unique rows only

## Notes
- The first item with a given `storeId + productId` combination should be kept; subsequent duplicates should be discarded
- The `storeId` is assigned during `ensureWarehouseLocationsAndNewFields()` processing, so deduplication must happen after storeId assignment
- Items without a `storeId` (undefined) should still be processed - the combination key would be `undefined:productId`
- This fix affects only mock data generation; real database data from Supabase would not have this issue
